# Container-level SecurityContext Examples
# These examples focus on container-specific security configurations

---
# Example 1: Web application with minimal privileges
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-web-deployment
  namespace: production
  labels:
    app: secure-web
    security.aws.com/profile: restricted
spec:
  replicas: 3
  selector:
    matchLabels:
      app: secure-web
  template:
    metadata:
      labels:
        app: secure-web
        security.aws.com/profile: restricted
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        runAsGroup: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      
      containers:
      - name: web-server
        image: nginx:1.21-alpine
        
        # Comprehensive container security context
        securityContext:
          # Privilege controls
          allowPrivilegeEscalation: false
          privileged: false
          
          # Filesystem controls
          readOnlyRootFilesystem: true
          
          # Capability management - drop all and add only what's needed
          capabilities:
            drop:
            - ALL
            # Uncomment only if specific capabilities are required
            # add:
            # - NET_BIND_SERVICE  # For binding to ports < 1024
            # - CHOWN            # For changing file ownership
            # - DAC_OVERRIDE     # For bypassing file permissions
            # - FOWNER           # For bypassing file ownership checks
            # - FSETID           # For setting file setuid/setgid bits
            # - KILL             # For sending signals to processes
            # - SETGID           # For setting group ID
            # - SETUID           # For setting user ID
            # - NET_RAW          # For using raw sockets
            # - SYS_CHROOT       # For using chroot
          
          # User/group controls (can override pod-level settings)
          runAsNonRoot: true
          runAsUser: 65534
          runAsGroup: 65534
          
          # Seccomp profile (can override pod-level)
          seccompProfile:
            type: RuntimeDefault
        
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        
        # Resource constraints for security
        resources:
          limits:
            memory: "256Mi"
            cpu: "200m"
            ephemeral-storage: "1Gi"
          requests:
            memory: "128Mi"
            cpu: "100m"
            ephemeral-storage: "500Mi"
        
        # Volume mounts for writable areas
        volumeMounts:
        - name: tmp-volume
          mountPath: /tmp
        - name: var-cache-nginx
          mountPath: /var/cache/nginx
        - name: var-run
          mountPath: /var/run
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        
        # Health checks
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        
        # Environment variables (avoid secrets here)
        env:
        - name: NGINX_PORT
          value: "8080"
        - name: NGINX_USER
          value: "nobody"
      
      volumes:
      - name: tmp-volume
        emptyDir:
          sizeLimit: "100Mi"
      - name: var-cache-nginx
        emptyDir:
          sizeLimit: "100Mi"
      - name: var-run
        emptyDir:
          sizeLimit: "10Mi"
      - name: nginx-config
        configMap:
          name: nginx-secure-config
          defaultMode: 0444  # Read-only

---
# Example 2: Database container with specific capability requirements
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: secure-database
  namespace: production
  labels:
    app: secure-database
    security.aws.com/profile: restricted
spec:
  serviceName: secure-database
  replicas: 1
  selector:
    matchLabels:
      app: secure-database
  template:
    metadata:
      labels:
        app: secure-database
        security.aws.com/profile: restricted
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 999  # postgres user
        runAsGroup: 999
        fsGroup: 999
        seccompProfile:
          type: RuntimeDefault
      
      containers:
      - name: postgres
        image: postgres:14-alpine
        
        securityContext:
          allowPrivilegeEscalation: false
          privileged: false
          readOnlyRootFilesystem: true
          
          # Database may need specific capabilities
          capabilities:
            drop:
            - ALL
            add:
            - CHOWN      # For changing file ownership
            - DAC_OVERRIDE  # For bypassing file permissions
            - FOWNER     # For bypassing file ownership checks
            - FSETID     # For setting file setuid/setgid bits
            - SETGID     # For setting group ID
            - SETUID     # For setting user ID
          
          runAsNonRoot: true
          runAsUser: 999
          runAsGroup: 999
        
        ports:
        - containerPort: 5432
          name: postgres
        
        resources:
          limits:
            memory: "1Gi"
            cpu: "500m"
          requests:
            memory: "512Mi"
            cpu: "250m"
        
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        - name: postgres-tmp
          mountPath: /tmp
        - name: postgres-run
          mountPath: /var/run/postgresql
        
        env:
        - name: POSTGRES_DB
          value: "appdb"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
          initialDelaySeconds: 5
          periodSeconds: 5
      
      volumes:
      - name: postgres-tmp
        emptyDir:
          sizeLimit: "100Mi"
      - name: postgres-run
        emptyDir:
          sizeLimit: "10Mi"
  
  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: gp3-encrypted
      resources:
        requests:
          storage: 10Gi

---
# Example 3: Init container with elevated privileges (when absolutely necessary)
apiVersion: v1
kind: Pod
metadata:
  name: secure-with-init
  namespace: production
  labels:
    app: secure-with-init
    security.aws.com/profile: restricted
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault
  
  # Init container that may need elevated privileges for setup
  initContainers:
  - name: setup-init
    image: alpine:3.18
    command: ["/bin/sh", "-c", "echo 'Setting up...' && chown -R 1000:1000 /shared-data"]
    
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      
      # Init container may need specific capabilities for setup
      capabilities:
        drop:
        - ALL
        add:
        - CHOWN      # For changing ownership of shared volume
        - FOWNER     # For file ownership operations
      
      # Init containers can run as root if absolutely necessary for setup
      runAsNonRoot: false
      runAsUser: 0
    
    resources:
      limits:
        memory: "128Mi"
        cpu: "100m"
      requests:
        memory: "64Mi"
        cpu: "50m"
    
    volumeMounts:
    - name: shared-data
      mountPath: /shared-data
    - name: init-tmp
      mountPath: /tmp
  
  # Main application container with restricted privileges
  containers:
  - name: main-app
    image: alpine:3.18
    command: ["/bin/sh", "-c", "while true; do echo 'App running'; sleep 30; done"]
    
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
      runAsNonRoot: true
      runAsUser: 1000
    
    resources:
      limits:
        memory: "256Mi"
        cpu: "200m"
      requests:
        memory: "128Mi"
        cpu: "100m"
    
    volumeMounts:
    - name: shared-data
      mountPath: /app/data
      readOnly: true
    - name: app-tmp
      mountPath: /tmp
  
  volumes:
  - name: shared-data
    emptyDir:
      sizeLimit: "1Gi"
  - name: init-tmp
    emptyDir:
      sizeLimit: "50Mi"
  - name: app-tmp
    emptyDir:
      sizeLimit: "100Mi"