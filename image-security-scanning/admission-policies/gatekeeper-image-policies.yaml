apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: requireimagesignature
  annotations:
    description: "Requires container images to be signed and verified"
spec:
  crd:
    spec:
      names:
        kind: RequireImageSignature
      validation:
        type: object
        properties:
          trustedRegistries:
            type: array
            items:
              type: string
          exemptImages:
            type: array
            items:
              type: string
          exemptNamespaces:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package requireimagesignature

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_image(container.image)
          not is_exempt_namespace
          not is_trusted_registry(container.image)
          msg := sprintf("Container image '%v' is not from a trusted registry", [container.image])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_image(container.image)
          not is_exempt_namespace
          not has_signature_annotation
          msg := sprintf("Container image '%v' does not have signature verification", [container.image])
        }

        is_exempt_image(image) {
          exempt_image := input.parameters.exemptImages[_]
          startswith(image, exempt_image)
        }

        is_exempt_namespace {
          exempt_namespace := input.parameters.exemptNamespaces[_]
          input.review.object.metadata.namespace == exempt_namespace
        }

        is_trusted_registry(image) {
          trusted_registry := input.parameters.trustedRegistries[_]
          startswith(image, trusted_registry)
        }

        has_signature_annotation {
          input.review.object.metadata.annotations["image.signature.verified"] == "true"
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: RequireImageSignature
metadata:
  name: require-signed-images
spec:
  match:
    - apiGroups: [""]
      kinds: ["Pod"]
    - apiGroups: ["apps"]
      kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    - apiGroups: ["batch"]
      kinds: ["Job", "CronJob"]
  parameters:
    trustedRegistries:
      - "123456789012.dkr.ecr.us-east-1.amazonaws.com/"
      - "public.ecr.aws/"
    exemptImages:
      - "k8s.gcr.io/"
      - "gcr.io/gke-release/"
    exemptNamespaces:
      - "kube-system"
      - "gatekeeper-system"
      - "cert-manager"

---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: requiresbomattestation
  annotations:
    description: "Requires container images to have SBOM attestations"
spec:
  crd:
    spec:
      names:
        kind: RequireSBOMAttestation
      validation:
        type: object
        properties:
          exemptNamespaces:
            type: array
            items:
              type: string
          exemptImages:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package requiresbomattestation

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_image(container.image)
          not is_exempt_namespace
          not has_sbom_annotation
          msg := sprintf("Container image '%v' does not have SBOM attestation", [container.image])
        }

        is_exempt_image(image) {
          exempt_image := input.parameters.exemptImages[_]
          startswith(image, exempt_image)
        }

        is_exempt_namespace {
          exempt_namespace := input.parameters.exemptNamespaces[_]
          input.review.object.metadata.namespace == exempt_namespace
        }

        has_sbom_annotation {
          input.review.object.metadata.annotations["sbom.attestation.verified"] == "true"
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: RequireSBOMAttestation
metadata:
  name: require-sbom-attestation
spec:
  match:
    - apiGroups: [""]
      kinds: ["Pod"]
    - apiGroups: ["apps"]
      kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    - apiGroups: ["batch"]
      kinds: ["Job", "CronJob"]
  parameters:
    exemptNamespaces:
      - "kube-system"
      - "gatekeeper-system"
      - "cert-manager"
    exemptImages:
      - "k8s.gcr.io/"
      - "gcr.io/gke-release/"

---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: requirevulnerabilityscan
  annotations:
    description: "Requires container images to pass vulnerability scans"
spec:
  crd:
    spec:
      names:
        kind: RequireVulnerabilityScan
      validation:
        type: object
        properties:
          maxCritical:
            type: integer
          maxHigh:
            type: integer
          exemptNamespaces:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package requirevulnerabilityscan

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_namespace
          not has_scan_annotation
          msg := sprintf("Container image '%v' does not have vulnerability scan results", [container.image])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_namespace
          has_scan_annotation
          critical_count := to_number(input.review.object.metadata.annotations["vulnerability.scan.critical"])
          critical_count > input.parameters.maxCritical
          msg := sprintf("Container image '%v' has %v critical vulnerabilities (max allowed: %v)", [container.image, critical_count, input.parameters.maxCritical])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_namespace
          has_scan_annotation
          high_count := to_number(input.review.object.metadata.annotations["vulnerability.scan.high"])
          high_count > input.parameters.maxHigh
          msg := sprintf("Container image '%v' has %v high vulnerabilities (max allowed: %v)", [container.image, high_count, input.parameters.maxHigh])
        }

        is_exempt_namespace {
          exempt_namespace := input.parameters.exemptNamespaces[_]
          input.review.object.metadata.namespace == exempt_namespace
        }

        has_scan_annotation {
          input.review.object.metadata.annotations["vulnerability.scan.status"] == "passed"
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: RequireVulnerabilityScan
metadata:
  name: require-vulnerability-scan
spec:
  match:
    - apiGroups: [""]
      kinds: ["Pod"]
    - apiGroups: ["apps"]
      kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    - apiGroups: ["batch"]
      kinds: ["Job", "CronJob"]
  parameters:
    maxCritical: 0
    maxHigh: 5
    exemptNamespaces:
      - "kube-system"
      - "gatekeeper-system"
      - "cert-manager"

---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: requireimageprovenance
  annotations:
    description: "Requires container images to have provenance attestations"
spec:
  crd:
    spec:
      names:
        kind: RequireImageProvenance
      validation:
        type: object
        properties:
          trustedBuilders:
            type: array
            items:
              type: string
          exemptNamespaces:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package requireimageprovenance

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_namespace
          not has_provenance_annotation
          msg := sprintf("Container image '%v' does not have provenance attestation", [container.image])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt_namespace
          has_provenance_annotation
          builder := input.review.object.metadata.annotations["provenance.builder"]
          not is_trusted_builder(builder)
          msg := sprintf("Container image '%v' was built by untrusted builder '%v'", [container.image, builder])
        }

        is_exempt_namespace {
          exempt_namespace := input.parameters.exemptNamespaces[_]
          input.review.object.metadata.namespace == exempt_namespace
        }

        has_provenance_annotation {
          input.review.object.metadata.annotations["provenance.verified"] == "true"
        }

        is_trusted_builder(builder) {
          trusted_builder := input.parameters.trustedBuilders[_]
          builder == trusted_builder
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: RequireImageProvenance
metadata:
  name: require-image-provenance
spec:
  match:
    - apiGroups: [""]
      kinds: ["Pod"]
    - apiGroups: ["apps"]
      kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    - apiGroups: ["batch"]
      kinds: ["Job", "CronJob"]
  parameters:
    trustedBuilders:
      - "AWS CodeBuild"
      - "GitHub Actions"
    exemptNamespaces:
      - "kube-system"
      - "gatekeeper-system"
      - "cert-manager"